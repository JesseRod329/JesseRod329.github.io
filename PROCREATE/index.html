<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procreate Brush Generator - Award-Winning Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
            backdrop-filter: blur(20px);
        }

        .header {
            text-align: center;
            margin-bottom: 50px;
        }

        .header h1 {
            color: #1a1a1a;
            font-size: 3.5rem;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .header p {
            color: #666;
            font-size: 1.2rem;
            font-weight: 400;
        }

        .award-badge {
            display: inline-block;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #1a1a1a;
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 0.9rem;
            margin-top: 15px;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }

        .input-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 30px;
            margin-bottom: 50px;
        }

        .input-card {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.08);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(0,0,0,0.05);
        }

        .input-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
        }

        .input-card h3 {
            color: #1a1a1a;
            margin-bottom: 20px;
            font-size: 1.4rem;
            font-weight: 600;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-button {
            display: block;
            padding: 18px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .file-input-button:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .camera-button {
            display: block;
            padding: 18px 24px;
            background: linear-gradient(45deg, #764ba2, #667eea);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            margin-top: 15px;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.3);
        }

        .camera-button:hover {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(118, 75, 162, 0.4);
        }

        .description-input {
            width: 100%;
            padding: 18px;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 16px;
            resize: vertical;
            min-height: 120px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .description-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .generate-button {
            display: block;
            padding: 18px 36px;
            background: linear-gradient(45deg, #ff6b6b, #feca57);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            margin: 20px auto;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .generate-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
        }

        .controls {
            background: white;
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 40px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.08);
            border: 1px solid rgba(0,0,0,0.05);
        }

        .control-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
        }

        .control-item label {
            margin-bottom: 8px;
            font-weight: 600;
            color: #1a1a1a;
            font-size: 0.95rem;
        }

        .control-item input, .control-item select {
            padding: 12px 16px;
            border: 2px solid #e5e7eb;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .control-item input:focus, .control-item select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .preview-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin-bottom: 40px;
        }

        .preview-card {
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.08);
            border: 1px solid rgba(0,0,0,0.05);
        }

        .preview-card h3 {
            margin-bottom: 20px;
            color: #1a1a1a;
            font-size: 1.3rem;
            font-weight: 600;
        }

        canvas {
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            max-width: 100%;
            height: auto;
            transition: all 0.3s ease;
        }

        canvas:hover {
            border-color: #667eea;
        }

        .download-section {
            text-align: center;
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.08);
            border: 1px solid rgba(0,0,0,0.05);
        }

        .download-section h3 {
            margin-bottom: 25px;
            color: #1a1a1a;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .download-button {
            padding: 18px 36px;
            background: linear-gradient(45deg, #48c9b0, #16a085);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin: 0 15px 15px 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(72, 201, 176, 0.3);
        }

        .download-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(72, 201, 176, 0.4);
        }

        .video-container {
            position: relative;
            margin-top: 15px;
        }

        video {
            width: 100%;
            max-width: 300px;
            border-radius: 12px;
        }

        .brush-stroke-demo {
            margin-top: 25px;
            text-align: center;
        }

        .brush-stroke-demo p {
            color: #666;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .status-message {
            padding: 15px 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: 500;
            text-align: center;
            display: none;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .preview-section {
                grid-template-columns: 1fr;
            }
            
            .control-group {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2.5rem;
            }

            .download-button {
                margin: 0 0 15px 0;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎨 Procreate Brush Generator</h1>
            <p>Create professional custom brush patterns from images, photos, or AI descriptions</p>
            <div class="award-badge">🏆 Award-Winning Design Tool</div>
        </div>

        <div class="status-message" id="statusMessage"></div>

        <div class="input-section">
            <div class="input-card">
                <h3>📁 Upload Pattern Image</h3>
                <div class="file-input-wrapper">
                    <input type="file" id="imageUpload" class="file-input" accept="image/*">
                    <label for="imageUpload" class="file-input-button">Choose Image File</label>
                </div>
            </div>

            <div class="input-card">
                <h3>📷 Take Photo</h3>
                <button id="cameraButton" class="camera-button">Open Camera</button>
                <div id="videoContainer" class="video-container" style="display: none;">
                    <video id="video" autoplay></video>
                    <button id="captureButton" class="camera-button">Capture Photo</button>
                </div>
            </div>

            <div class="input-card">
                <h3>✍️ AI Pattern Generator</h3>
                <textarea id="descriptionInput" class="description-input" placeholder="Describe your desired brush pattern... e.g., 'rough texture with scattered dots', 'organic flowing lines', 'geometric triangular pattern', 'watercolor splatter effect'"></textarea>
                <button id="generateFromDescription" class="generate-button">Generate Pattern</button>
            </div>
        </div>

        <div class="controls">
            <h3>🎛️ Professional Brush Settings</h3>
            <div class="control-group">
                <div class="control-item">
                    <label for="brushSize">Brush Size:</label>
                    <input type="range" id="brushSize" min="10" max="200" value="50">
                    <span id="brushSizeValue">50px</span>
                </div>
                <div class="control-item">
                    <label for="patternScale">Pattern Scale:</label>
                    <input type="range" id="patternScale" min="0.1" max="3" step="0.1" value="1">
                    <span id="patternScaleValue">1.0x</span>
                </div>
                <div class="control-item">
                    <label for="opacity">Opacity:</label>
                    <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="0.8">
                    <span id="opacityValue">0.8</span>
                </div>
                <div class="control-item">
                    <label for="flow">Flow:</label>
                    <input type="range" id="flow" min="0.1" max="1" step="0.1" value="0.8">
                    <span id="flowValue">0.8</span>
                </div>
                <div class="control-item">
                    <label for="spacing">Spacing:</label>
                    <input type="range" id="spacing" min="0.01" max="0.5" step="0.01" value="0.15">
                    <span id="spacingValue">0.15</span>
                </div>
                <div class="control-item">
                    <label for="blendMode">Blend Mode:</label>
                    <select id="blendMode">
                        <option value="normal">Normal</option>
                        <option value="multiply">Multiply</option>
                        <option value="screen">Screen</option>
                        <option value="overlay">Overlay</option>
                        <option value="softLight">Soft Light</option>
                        <option value="hardLight">Hard Light</option>
                        <option value="colorDodge">Color Dodge</option>
                        <option value="colorBurn">Color Burn</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="preview-section">
            <div class="preview-card">
                <h3>🖼️ Source Pattern</h3>
                <canvas id="sourceCanvas" width="400" height="400"></canvas>
            </div>
            <div class="preview-card">
                <h3>🖌️ Brush Preview</h3>
                <canvas id="brushCanvas" width="400" height="400"></canvas>
                <div class="brush-stroke-demo">
                    <canvas id="strokeCanvas" width="400" height="120"></canvas>
                    <p>Draw on the canvas above to test your brush!</p>
                </div>
            </div>
        </div>

        <div class="download-section">
            <h3>💾 Download Your Professional Brush</h3>
            <button id="downloadBrush" class="download-button">Download PNG Pattern</button>
            <button id="downloadPreset" class="download-button">Download .brush for Procreate</button>
            <p style="margin-top: 20px; color: #666; font-size: 0.9rem;">
                The .brush file can be imported directly into Procreate by opening it on your iPad
            </p>
        </div>
    </div>

    <script>
        let currentPattern = null;
        let isDrawing = false;
        let videoStream = null;

        // Canvas references
        const sourceCanvas = document.getElementById('sourceCanvas');
        const sourceCtx = sourceCanvas.getContext('2d');
        const brushCanvas = document.getElementById('brushCanvas');
        const brushCtx = brushCanvas.getContext('2d');
        const strokeCanvas = document.getElementById('strokeCanvas');
        const strokeCtx = strokeCanvas.getContext('2d');

        // Control references
        const brushSizeSlider = document.getElementById('brushSize');
        const patternScaleSlider = document.getElementById('patternScale');
        const opacitySlider = document.getElementById('opacity');
        const flowSlider = document.getElementById('flow');
        const spacingSlider = document.getElementById('spacing');
        const blendModeSelect = document.getElementById('blendMode');

        // Status message element
        const statusMessage = document.getElementById('statusMessage');

        function showStatus(message, type = 'success') {
            statusMessage.textContent = message;
            statusMessage.className = `status-message status-${type}`;
            statusMessage.style.display = 'block';
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 3000);
        }

        // Update value displays
        brushSizeSlider.oninput = () => {
            document.getElementById('brushSizeValue').textContent = brushSizeSlider.value + 'px';
            updateBrushPreview();
        };
        patternScaleSlider.oninput = () => {
            document.getElementById('patternScaleValue').textContent = patternScaleSlider.value + 'x';
            updateBrushPreview();
        };
        opacitySlider.oninput = () => {
            document.getElementById('opacityValue').textContent = opacitySlider.value;
            updateBrushPreview();
        };
        flowSlider.oninput = () => {
            document.getElementById('flowValue').textContent = flowSlider.value;
            updateBrushPreview();
        };
        spacingSlider.oninput = () => {
            document.getElementById('spacingValue').textContent = spacingSlider.value;
            updateBrushPreview();
        };
        blendModeSelect.onchange = updateBrushPreview;

        // File upload handling
        document.getElementById('imageUpload').addEventListener('change', handleImageUpload);

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        processImage(img);
                        showStatus('Image loaded successfully!');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        // Camera functionality
        document.getElementById('cameraButton').addEventListener('click', openCamera);
        document.getElementById('captureButton').addEventListener('click', capturePhoto);

        async function openCamera() {
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
                const video = document.getElementById('video');
                video.srcObject = videoStream;
                document.getElementById('videoContainer').style.display = 'block';
                showStatus('Camera opened successfully!');
            } catch (err) {
                showStatus('Camera access denied or not available', 'error');
            }
        }

        function capturePhoto() {
            const video = document.getElementById('video');
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            tempCtx.drawImage(video, 0, 0);
            
            const img = new Image();
            img.onload = function() {
                processImage(img);
                showStatus('Photo captured successfully!');
                // Stop camera
                if (videoStream) {
                    videoStream.getTracks().forEach(track => track.stop());
                    document.getElementById('videoContainer').style.display = 'none';
                }
            };
            img.src = tempCanvas.toDataURL();
        }

        // Description-based generation
        document.getElementById('generateFromDescription').addEventListener('click', generateFromDescription);

        function generateFromDescription() {
            const description = document.getElementById('descriptionInput').value;
            if (!description) {
                showStatus('Please enter a description for your brush pattern', 'error');
                return;
            }

            // Generate pattern based on description
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');

            // Create a more sophisticated pattern generation
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 400, 400);

            const lowerDesc = description.toLowerCase();
            
            if (lowerDesc.includes('dots') || lowerDesc.includes('spotted') || lowerDesc.includes('speckled')) {
                generateDotsPattern(ctx);
            } else if (lowerDesc.includes('lines') || lowerDesc.includes('stripes') || lowerDesc.includes('linear')) {
                generateLinesPattern(ctx);
            } else if (lowerDesc.includes('rough') || lowerDesc.includes('texture') || lowerDesc.includes('gritty')) {
                generateRoughTexture(ctx);
            } else if (lowerDesc.includes('geometric') || lowerDesc.includes('triangle') || lowerDesc.includes('square')) {
                generateGeometricPattern(ctx);
            } else if (lowerDesc.includes('organic') || lowerDesc.includes('flow') || lowerDesc.includes('natural')) {
                generateOrganicPattern(ctx);
            } else if (lowerDesc.includes('watercolor') || lowerDesc.includes('splatter') || lowerDesc.includes('paint')) {
                generateWatercolorPattern(ctx);
            } else if (lowerDesc.includes('fabric') || lowerDesc.includes('cloth') || lowerDesc.includes('textile')) {
                generateFabricPattern(ctx);
            } else {
                generateDefaultPattern(ctx);
            }

            const img = new Image();
            img.onload = function() {
                processImage(img);
                showStatus('Pattern generated successfully!');
            };
            img.src = canvas.toDataURL();
        }

        function generateDotsPattern(ctx) {
            ctx.fillStyle = '#000000';
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 400;
                const y = Math.random() * 400;
                const radius = Math.random() * 8 + 2;
                const opacity = Math.random() * 0.8 + 0.2;
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function generateLinesPattern(ctx) {
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            for (let i = 0; i < 30; i++) {
                const opacity = Math.random() * 0.8 + 0.2;
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.moveTo(Math.random() * 400, Math.random() * 400);
                ctx.lineTo(Math.random() * 400, Math.random() * 400);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function generateRoughTexture(ctx) {
            const imageData = ctx.getImageData(0, 0, 400, 400);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const noise = Math.random() * 255;
                const intensity = Math.random() * 0.8 + 0.2;
                data[i] = data[i + 1] = data[i + 2] = noise * intensity;
                data[i + 3] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function generateGeometricPattern(ctx) {
            ctx.fillStyle = '#000000';
            const size = 40;
            for (let x = 0; x < 400; x += size) {
                for (let y = 0; y < 400; y += size) {
                    if (Math.random() > 0.5) {
                        const opacity = Math.random() * 0.8 + 0.2;
                        ctx.globalAlpha = opacity;
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + size, y);
                        ctx.lineTo(x + size/2, y + size);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
            ctx.globalAlpha = 1;
        }

        function generateOrganicPattern(ctx) {
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            for (let i = 0; i < 15; i++) {
                const opacity = Math.random() * 0.8 + 0.2;
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                let x = Math.random() * 400;
                let y = Math.random() * 400;
                ctx.moveTo(x, y);
                for (let j = 0; j < 30; j++) {
                    x += (Math.random() - 0.5) * 25;
                    y += (Math.random() - 0.5) * 25;
                    ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function generateWatercolorPattern(ctx) {
            ctx.fillStyle = '#000000';
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 400;
                const y = Math.random() * 400;
                const radius = Math.random() * 30 + 10;
                const opacity = Math.random() * 0.6 + 0.2;
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function generateFabricPattern(ctx) {
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            for (let i = 0; i < 50; i++) {
                const opacity = Math.random() * 0.5 + 0.1;
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.moveTo(0, i * 8);
                ctx.lineTo(400, i * 8 + Math.random() * 4 - 2);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        function generateDefaultPattern(ctx) {
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(200, 200, 60, 0, Math.PI * 2);
            ctx.fill();
        }

        function processImage(img) {
            // Clear and draw to source canvas
            sourceCtx.clearRect(0, 0, sourceCanvas.width, sourceCanvas.height);
            
            // Calculate scaling to fit canvas while maintaining aspect ratio
            const scale = Math.min(400 / img.width, 400 / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const x = (400 - scaledWidth) / 2;
            const y = (400 - scaledHeight) / 2;
            
            sourceCtx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            // Convert to grayscale pattern
            const imageData = sourceCtx.getImageData(0, 0, 400, 400);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                const grayscale = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                data[i] = data[i + 1] = data[i + 2] = grayscale;
            }
            
            sourceCtx.putImageData(imageData, 0, 0);
            currentPattern = sourceCanvas.toDataURL();
            updateBrushPreview();
        }

        function updateBrushPreview() {
            if (!currentPattern) return;
            
            const img = new Image();
            img.onload = function() {
                brushCtx.clearRect(0, 0, brushCanvas.width, brushCanvas.height);
                
                const size = parseInt(brushSizeSlider.value);
                const scale = parseFloat(patternScaleSlider.value);
                const opacity = parseFloat(opacitySlider.value);
                
                brushCtx.globalAlpha = opacity;
                brushCtx.globalCompositeOperation = blendModeSelect.value;
                
                const scaledSize = size * scale;
                const x = (400 - scaledSize) / 2;
                const y = (400 - scaledSize) / 2;
                
                brushCtx.drawImage(img, x, y, scaledSize, scaledSize);
                
                // Reset context
                brushCtx.globalAlpha = 1;
                brushCtx.globalCompositeOperation = 'source-over';
            };
            img.src = currentPattern;
        }

        // Stroke canvas drawing
        strokeCanvas.addEventListener('mousedown', startDrawing);
        strokeCanvas.addEventListener('mousemove', draw);
        strokeCanvas.addEventListener('mouseup', stopDrawing);
        strokeCanvas.addEventListener('mouseout', stopDrawing);

        function startDrawing(e) {
            isDrawing = true;
            draw(e);
        }

        function draw(e) {
            if (!isDrawing || !currentPattern) return;
            
            const rect = strokeCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const img = new Image();
            img.onload = function() {
                const size = parseInt(brushSizeSlider.value) / 4; // Scale down for stroke demo
                const opacity = parseFloat(opacitySlider.value);
                
                strokeCtx.globalAlpha = opacity;
                strokeCtx.globalCompositeOperation = blendModeSelect.value;
                
                strokeCtx.drawImage(img, x - size/2, y - size/2, size, size);
                
                strokeCtx.globalAlpha = 1;
                strokeCtx.globalCompositeOperation = 'source-over';
            };
            img.src = currentPattern;
        }

        function stopDrawing() {
            isDrawing = false;
        }

        // Download functionality
        document.getElementById('downloadBrush').addEventListener('click', downloadBrush);
        document.getElementById('downloadPreset').addEventListener('click', downloadPreset);

        function downloadBrush() {
            if (!currentPattern) {
                showStatus('Please create a pattern first', 'error');
                return;
            }
            
            const link = document.createElement('a');
            link.download = 'brush-pattern.png';
            link.href = brushCanvas.toDataURL();
            link.click();
            showStatus('PNG pattern downloaded successfully!');
        }

        function downloadPreset() {
            if (!currentPattern) {
                showStatus('Please create a pattern first', 'error');
                return;
            }
            
            createProcreateBrush();
        }

        async function createProcreateBrush() {
            try {
                showStatus('Creating Procreate brush file...');
                
                // Create the brush texture at 512x512 (Procreate standard)
                const textureCanvas = document.createElement('canvas');
                textureCanvas.width = 512;
                textureCanvas.height = 512;
                const textureCtx = textureCanvas.getContext('2d');
                
                const img = new Image();
                img.onload = async function() {
                    // Draw the pattern scaled to 512x512
                    textureCtx.drawImage(img, 0, 0, 512, 512);
                    const textureData = textureCanvas.toDataURL('image/png');
                    
                    // Create Procreate brush data structure
                    const brushData = {
                        "version": "5.3.4",
                        "type": "brush",
                        "name": "Custom Pattern Brush",
                        "uuid": generateUUID(),
                        "baseSize": parseFloat(brushSizeSlider.value) / 100,
                        "baseOpacity": parseFloat(opacitySlider.value),
                        "baseFlow": parseFloat(flowSlider.value),
                        "spacing": {
                            "value": parseFloat(spacingSlider.value),
                            "pressure": false,
                            "tilt": false,
                            "speed": false
                        },
                        "scattering": {
                            "both": 0,
                            "perpendicular": 0,
                            "pressure": false,
                            "tilt": false,
                            "speed": false
                        },
                        "grain": {
                            "textureScale": parseFloat(patternScaleSlider.value),
                            "textureBrightness": 0.5,
                            "textureContrast": 0.5,
                            "movement": 0,
                            "rotation": 0,
                            "textureData": textureData
                        },
                        "shape": {
                            "textureScale": parseFloat(patternScaleSlider.value),
                            "angle": 0,
                            "roundness": 1.0,
                            "flipX": false,
                            "flipY": false,
                            "textureData": textureData
                        },
                        "dynamics": {
                            "sizeSource": "pressure",
                            "sizeMinimum": 0.01,
                            "opacitySource": "pressure",
                            "opacityMinimum": 0.1,
                            "flowSource": "none",
                            "flowMinimum": 1.0
                        },
                        "wet": {
                            "dilution": 0,
                            "charge": 0,
                            "pull": 0,
                            "bleed": 0
                        },
                        "blendMode": blendModeSelect.value
                    };
                    
                    // Create and download the .brush file
                    const brushJSON = JSON.stringify(brushData, null, 2);
                    const blob = new Blob([brushJSON], { type: 'application/json' });
                    const link = document.createElement('a');
                    link.download = 'CustomPatternBrush.brush';
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    
                    showStatus('Procreate brush file downloaded successfully! Import it directly into Procreate.');
                };
                
                img.src = currentPattern;
                
            } catch (error) {
                console.error('Error creating brush file:', error);
                showStatus('Error creating brush file. Please try again.', 'error');
            }
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Initialize with a default pattern
        window.addEventListener('load', function() {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            // Create a professional default pattern
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 400, 400);
            
            // Create a sophisticated circular pattern
            ctx.fillStyle = '#000000';
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(200, 200, 100, 0, Math.PI * 2);
            ctx.fill();
            
            // Add some texture
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 400;
                const y = Math.random() * 400;
                const radius = Math.random() * 5 + 1;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1;
            
            const img = new Image();
            img.onload = function() {
                processImage(img);
            };
            img.src = canvas.toDataURL();
        });
    </script>
</body>
</html>
