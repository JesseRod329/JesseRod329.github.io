const input = document.getElementById('markdownInput'), svg = d3.select('#mindMap'); function parseMarkdown(text) { const lines = text.split('\n').filter(l => l.trim()), root = { name: 'Root', children: [] }; let stack = [{ node: root, level: -1 }]; lines.forEach(line => { const match = line.match(/^(\s*)([-*#])\s*(.+)$/); if (!match) return; const [, indent, marker, content] = match, level = indent.length / 2, node = { name: content, children: [] }; while (stack.length > 0 && stack[stack.length - 1].level >= level) stack.pop(); stack[stack.length - 1].node.children.push(node); stack.push({ node, level }) }); return root } function renderMindMap(data) { const width = svg.node().getBoundingClientRect().width, height = svg.node().getBoundingClientRect().height; svg.selectAll('*').remove(); const tree = d3.tree().size([height - 100, width - 200]), root = d3.hierarchy(data), treeData = tree(root); const g = svg.append('g').attr('transform', 'translate(100,50)'); g.selectAll('.link').data(treeData.links()).enter().append('path').attr('class', 'link').attr('d', d3.linkHorizontal().x(d => d.y).y(d => d.x)).attr('fill', 'none').attr('stroke', '#6366f1').attr('stroke-width', 2); const node = g.selectAll('.node').data(treeData.descendants()).enter().append('g').attr('transform', d => `translate(${d.y},${d.x})`); node.append('circle').attr('r', 6).attr('fill', '#8b5cf6'); node.append('text').attr('dy', 3).attr('x', d => d.children ? -12 : 12).style('text-anchor', d => d.children ? 'end' : 'start').style('fill', '#fff').style('font-size', '12px').text(d => d.data.name) } input.addEventListener('input', () => renderMindMap(parseMarkdown(input.value))); renderMindMap(parseMarkdown(input.value));
